<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - .coverage.base - openFrameworks/math/ofMatrix4x4.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">openFrameworks/math</a> - ofMatrix4x4.cpp<span style="font-size: 80%;"> (source / <a href="ofMatrix4x4.cpp.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">.coverage.base</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">212</td>
            <td class="headerCovTableEntry">707</td>
            <td class="headerCovTableEntryLo">30.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2012-08-09</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntry">62</td>
            <td class="headerCovTableEntryLo">29.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : </a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #include &quot;ofMatrix4x4.h&quot;
<span class="lineNum">       6 </span>            : #include &lt;limits&gt;
<span class="lineNum">       7 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">       8 </span>            : #include &quot;ofConstants.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #if (_MSC_VER)
<span class="lineNum">      11 </span>            : #undef min
<span class="lineNum">      12 </span>            : // see: http://stackoverflow.com/questions/1904635/warning-c4003-and-errors-c2589-and-c2059-on-x-stdnumericlimitsintmax
<a name="13"><span class="lineNum">      13 </span>            : #endif</a>
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span><span class="lineNoCov">          0 : inline bool equivalent(double lhs,double rhs,double epsilon=1e-6)</span>
<a name="16"><span class="lineNum">      16 </span><span class="lineNoCov">          0 : { double delta = rhs-lhs; return delta&lt;0.0?delta&gt;=-epsilon:delta&lt;=epsilon; }</span></a>
<span class="lineNum">      17 </span>            : template&lt;typename T&gt;
<span class="lineNum">      18 </span><span class="lineCov">    1492958 : inline T square(T v) { return v*v; }</span>
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #define SET_ROW(row, v1, v2, v3, v4 )    \
<span class="lineNum">      21 </span>            : _mat[(row)][0] = (v1); \
<span class="lineNum">      22 </span>            : _mat[(row)][1] = (v2); \
<span class="lineNum">      23 </span>            : _mat[(row)][2] = (v3); \
<span class="lineNum">      24 </span>            : _mat[(row)][3] = (v4);
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #define INNER_PRODUCT(a,b,r,c) \
<span class="lineNum">      27 </span>            : ((a)._mat[r][0] * (b)._mat[0][c]) \
<span class="lineNum">      28 </span>            : +((a)._mat[r][1] * (b)._mat[1][c]) \
<span class="lineNum">      29 </span>            : +((a)._mat[r][2] * (b)._mat[2][c]) \
<a name="30"><span class="lineNum">      30 </span>            : +((a)._mat[r][3] * (b)._mat[3][c])</a>
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span><span class="lineNoCov">          0 : ofMatrix4x4::ofMatrix4x4( float a00, float a01, float a02, float a03,</span>
<span class="lineNum">      33 </span>            :                                                                                          float a10, float a11, float a12, float a13,
<span class="lineNum">      34 </span>            :                                                                                          float a20, float a21, float a22, float a23,
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :                                                                                          float a30, float a31, float a32, float a33)</span>
<span class="lineNum">      36 </span>            : {
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :     SET_ROW(0, a00, a01, a02, a03 )</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :     SET_ROW(1, a10, a11, a12, a13 )</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     SET_ROW(2, a20, a21, a22, a23 )</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :     SET_ROW(3, a30, a31, a32, a33 )</span>
<a name="41"><span class="lineNum">      41 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineNoCov">          0 : void ofMatrix4x4::set( float a00, float a01, float a02, float a03,</span>
<span class="lineNum">      44 </span>            :                                                                 float a10, float a11, float a12, float a13,
<span class="lineNum">      45 </span>            :                                                                 float a20, float a21, float a22, float a23,
<span class="lineNum">      46 </span>            :                                                                 float a30, float a31, float a32, float a33)
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :     SET_ROW(0, a00, a01, a02, a03 )</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :     SET_ROW(1, a10, a11, a12, a13 )</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     SET_ROW(2, a20, a21, a22, a23 )</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :     SET_ROW(3, a30, a31, a32, a33 )</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #define QX  q._v[0]
<span class="lineNum">      55 </span>            : #define QY  q._v[1]
<span class="lineNum">      56 </span>            : #define QZ  q._v[2]
<a name="57"><span class="lineNum">      57 </span>            : #define QW  q._v[3]</a>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span><span class="lineCov">      23437 : void ofMatrix4x4::setRotate(const ofQuaternion&amp; q)</span>
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span><span class="lineCov">      23437 :     double length2 = q.length2();</span>
<span class="lineNum">      62 </span><span class="lineCov">      23437 :     if (fabs(length2) &lt;= std::numeric_limits&lt;double&gt;::min())</span>
<span class="lineNum">      63 </span>            :     {
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :         _mat[0][0] = 1.0; _mat[1][0] = 0.0; _mat[2][0] = 0.0;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         _mat[0][1] = 0.0; _mat[1][1] = 1.0; _mat[2][1] = 0.0;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :         _mat[0][2] = 0.0; _mat[1][2] = 0.0; _mat[2][2] = 1.0;</span>
<span class="lineNum">      67 </span>            :     }
<span class="lineNum">      68 </span>            :     else
<span class="lineNum">      69 </span>            :     {
<span class="lineNum">      70 </span>            :         double rlength2;
<span class="lineNum">      71 </span>            :         // normalize quat if required.
<span class="lineNum">      72 </span>            :         // We can avoid the expensive sqrt in this case since all 'coefficients' below are products of two q components.
<span class="lineNum">      73 </span>            :         // That is a square of a square root, so it is possible to avoid that
<span class="lineNum">      74 </span><span class="lineCov">      23437 :         if (length2 != 1.0)</span>
<span class="lineNum">      75 </span>            :         {
<span class="lineNum">      76 </span><span class="lineCov">      12548 :             rlength2 = 2.0/length2;</span>
<span class="lineNum">      77 </span>            :         }
<span class="lineNum">      78 </span>            :         else
<span class="lineNum">      79 </span>            :         {
<span class="lineNum">      80 </span><span class="lineCov">      10889 :             rlength2 = 2.0;</span>
<span class="lineNum">      81 </span>            :         }
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :         // Source: Gamasutra, Rotating Objects Using Quaternions
<span class="lineNum">      84 </span>            :         //
<span class="lineNum">      85 </span>            :         //http://www.gamasutra.com/features/19980703/quaternions_01.htm
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :         double wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :         // calculate coefficients
<span class="lineNum">      90 </span><span class="lineCov">      23437 :         x2 = rlength2*QX;</span>
<span class="lineNum">      91 </span><span class="lineCov">      23437 :         y2 = rlength2*QY;</span>
<span class="lineNum">      92 </span><span class="lineCov">      23437 :         z2 = rlength2*QZ;</span>
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span><span class="lineCov">      23437 :         xx = QX * x2;</span>
<span class="lineNum">      95 </span><span class="lineCov">      23437 :         xy = QX * y2;</span>
<span class="lineNum">      96 </span><span class="lineCov">      23437 :         xz = QX * z2;</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineCov">      23437 :         yy = QY * y2;</span>
<span class="lineNum">      99 </span><span class="lineCov">      23437 :         yz = QY * z2;</span>
<span class="lineNum">     100 </span><span class="lineCov">      23437 :         zz = QZ * z2;</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineCov">      23437 :         wx = QW * x2;</span>
<span class="lineNum">     103 </span><span class="lineCov">      23437 :         wy = QW * y2;</span>
<span class="lineNum">     104 </span><span class="lineCov">      23437 :         wz = QW * z2;</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :         // Note.  Gamasutra gets the matrix assignments inverted, resulting
<span class="lineNum">     107 </span>            :         // in left-handed rotations, which is contrary to OpenGL and OSG's
<span class="lineNum">     108 </span>            :         // methodology.  The matrix assignment has been altered in the next
<span class="lineNum">     109 </span>            :         // few lines of code to do the right thing.
<span class="lineNum">     110 </span>            :         // Don Burns - Oct 13, 2001
<span class="lineNum">     111 </span><span class="lineCov">      23437 :         _mat[0][0] = 1.0 - (yy + zz);</span>
<span class="lineNum">     112 </span><span class="lineCov">      23437 :         _mat[1][0] = xy - wz;</span>
<span class="lineNum">     113 </span><span class="lineCov">      23437 :         _mat[2][0] = xz + wy;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineCov">      23437 :         _mat[0][1] = xy + wz;</span>
<span class="lineNum">     117 </span><span class="lineCov">      23437 :         _mat[1][1] = 1.0 - (xx + zz);</span>
<span class="lineNum">     118 </span><span class="lineCov">      23437 :         _mat[2][1] = yz - wx;</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineCov">      23437 :         _mat[0][2] = xz - wy;</span>
<span class="lineNum">     121 </span><span class="lineCov">      23437 :         _mat[1][2] = yz + wx;</span>
<span class="lineNum">     122 </span><span class="lineCov">      23437 :         _mat[2][2] = 1.0 - (xx + yy);</span>
<span class="lineNum">     123 </span>            :     }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : #if 0
<span class="lineNum">     126 </span>            :     _mat[0][3] = 0.0;
<span class="lineNum">     127 </span>            :     _mat[1][3] = 0.0;
<span class="lineNum">     128 </span>            :     _mat[2][3] = 0.0;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :     _mat[3][0] = 0.0;
<span class="lineNum">     131 </span>            :     _mat[3][1] = 0.0;
<span class="lineNum">     132 </span>            :     _mat[3][2] = 0.0;
<span class="lineNum">     133 </span>            :     _mat[3][3] = 1.0;
<span class="lineNum">     134 </span>            : #endif
<span class="lineNum">     135 </span><span class="lineCov">      23437 : }</span>
<span class="lineNum">     136 </span>            : //
<span class="lineNum">     137 </span>            : //ofQuaternion ofMatrix4x4::getRotate() const {
<span class="lineNum">     138 </span>            : //      ofVec4f q;
<span class="lineNum">     139 </span>            : //      float trace = _mat[0][0] + _mat[1][1] + _mat[2][2]; // I removed + 1.0f; see discussion with Ethan
<span class="lineNum">     140 </span>            : //      if( trace &gt; 0 ) {// I changed M_EPSILON to 0
<span class="lineNum">     141 </span>            : //              float s = 0.5f / sqrtf(trace+ 1.0f);
<span class="lineNum">     142 </span>            : //              q.w = 0.25f / s;
<span class="lineNum">     143 </span>            : //              q.x = ( _mat[2][1] - _mat[1][2] ) * s;
<span class="lineNum">     144 </span>            : //              q.y = ( _mat[0][2] - _mat[2][0] ) * s;
<span class="lineNum">     145 </span>            : //              q.z = ( _mat[1][0] - _mat[0][1] ) * s;
<span class="lineNum">     146 </span>            : //      } else {
<span class="lineNum">     147 </span>            : //              if ( _mat[0][0] &gt; _mat[1][1] &amp;&amp; _mat[0][0] &gt; _mat[2][2] ) {
<span class="lineNum">     148 </span>            : //                      float s = 2.0f * sqrtf( 1.0f + _mat[0][0] - _mat[1][1] - _mat[2][2]);
<span class="lineNum">     149 </span>            : //                      q.w = (_mat[2][1] - _mat[1][2] ) / s;
<span class="lineNum">     150 </span>            : //                      q.x = 0.25f * s;
<span class="lineNum">     151 </span>            : //                      q.y = (_mat[0][1] + _mat[1][0] ) / s;
<span class="lineNum">     152 </span>            : //                      q.z = (_mat[0][2] + _mat[2][0] ) / s;
<span class="lineNum">     153 </span>            : //              } else if (_mat[1][1] &gt; _mat[2][2]) {
<span class="lineNum">     154 </span>            : //                      float s = 2.0f * sqrtf( 1.0f + _mat[1][1] - _mat[0][0] - _mat[2][2]);
<span class="lineNum">     155 </span>            : //                      q.w = (_mat[0][2] - _mat[2][0] ) / s;
<span class="lineNum">     156 </span>            : //                      q.x = (_mat[0][1] + _mat[1][0] ) / s;
<span class="lineNum">     157 </span>            : //                      q.y = 0.25f * s;
<span class="lineNum">     158 </span>            : //                      q.z = (_mat[1][2] + _mat[2][1] ) / s;
<span class="lineNum">     159 </span>            : //              } else {
<span class="lineNum">     160 </span>            : //                      float s = 2.0f * sqrtf( 1.0f + _mat[2][2] - _mat[0][0] - _mat[1][1] );
<span class="lineNum">     161 </span>            : //                      q.w = (_mat[1][0] - _mat[0][1] ) / s;
<span class="lineNum">     162 </span>            : //                      q.x = (_mat[0][2] + _mat[2][0] ) / s;
<span class="lineNum">     163 </span>            : //                      q.y = (_mat[1][2] + _mat[2][1] ) / s;
<span class="lineNum">     164 </span>            : //                      q.z = 0.25f * s;
<span class="lineNum">     165 </span>            : //              }
<span class="lineNum">     166 </span>            : //      }
<span class="lineNum">     167 </span>            : //      return ofQuaternion(q.x, q.y, q.z, q.w);
<span class="lineNum">     168 </span>            : //}
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : //#define COMPILE_getRotate_David_Spillings_Mk1
<span class="lineNum">     171 </span>            : //#define COMPILE_getRotate_David_Spillings_Mk2
<span class="lineNum">     172 </span>            : #define COMPILE_getRotate_Original
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : #ifdef COMPILE_getRotate_David_Spillings_Mk1
<span class="lineNum">     175 </span>            : // David Spillings implementation Mk 1
<span class="lineNum">     176 </span>            : ofQuaternion ofMatrix4x4::getRotate() const
<span class="lineNum">     177 </span>            : {
<span class="lineNum">     178 </span>            :         ofQuaternion q;
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :     float s;
<span class="lineNum">     181 </span>            :     float tq[4];
<span class="lineNum">     182 </span>            :     int    i, j;
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :     // Use tq to store the largest trace
<span class="lineNum">     185 </span>            :     tq[0] = 1 + _mat[0][0]+_mat[1][1]+_mat[2][2];
<span class="lineNum">     186 </span>            :     tq[1] = 1 + _mat[0][0]-_mat[1][1]-_mat[2][2];
<span class="lineNum">     187 </span>            :     tq[2] = 1 - _mat[0][0]+_mat[1][1]-_mat[2][2];
<span class="lineNum">     188 </span>            :     tq[3] = 1 - _mat[0][0]-_mat[1][1]+_mat[2][2];
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     // Find the maximum (could also use stacked if's later)
<span class="lineNum">     191 </span>            :     j = 0;
<span class="lineNum">     192 </span>            :     for(i=1;i&lt;4;i++) j = (tq[i]&gt;tq[j])? i : j;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     // check the diagonal
<span class="lineNum">     195 </span>            :     if (j==0)
<span class="lineNum">     196 </span>            :     {
<span class="lineNum">     197 </span>            :         /* perform instant calculation */
<span class="lineNum">     198 </span>            :         QW = tq[0];
<span class="lineNum">     199 </span>            :         QX = _mat[1][2]-_mat[2][1];
<span class="lineNum">     200 </span>            :         QY = _mat[2][0]-_mat[0][2];
<span class="lineNum">     201 </span>            :         QZ = _mat[0][1]-_mat[1][0];
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span>            :     else if (j==1)
<span class="lineNum">     204 </span>            :     {
<span class="lineNum">     205 </span>            :         QW = _mat[1][2]-_mat[2][1];
<span class="lineNum">     206 </span>            :         QX = tq[1];
<span class="lineNum">     207 </span>            :         QY = _mat[0][1]+_mat[1][0];
<span class="lineNum">     208 </span>            :         QZ = _mat[2][0]+_mat[0][2];
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span>            :     else if (j==2)
<span class="lineNum">     211 </span>            :     {
<span class="lineNum">     212 </span>            :         QW = _mat[2][0]-_mat[0][2];
<span class="lineNum">     213 </span>            :         QX = _mat[0][1]+_mat[1][0];
<span class="lineNum">     214 </span>            :         QY = tq[2];
<span class="lineNum">     215 </span>            :         QZ = _mat[1][2]+_mat[2][1];
<span class="lineNum">     216 </span>            :     }
<span class="lineNum">     217 </span>            :     else /* if (j==3) */
<span class="lineNum">     218 </span>            :     {
<span class="lineNum">     219 </span>            :         QW = _mat[0][1]-_mat[1][0];
<span class="lineNum">     220 </span>            :         QX = _mat[2][0]+_mat[0][2];
<span class="lineNum">     221 </span>            :         QY = _mat[1][2]+_mat[2][1];
<span class="lineNum">     222 </span>            :         QZ = tq[3];
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     s = sqrt(0.25/tq[j]);
<span class="lineNum">     226 </span>            :     QW *= s;
<span class="lineNum">     227 </span>            :     QX *= s;
<span class="lineNum">     228 </span>            :     QY *= s;
<span class="lineNum">     229 </span>            :     QZ *= s;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :     return q;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : }
<span class="lineNum">     234 </span>            : #endif
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : #ifdef COMPILE_getRotate_David_Spillings_Mk2
<span class="lineNum">     238 </span>            : // David Spillings implementation Mk 2
<span class="lineNum">     239 </span>            : ofQuaternion ofMatrix4x4::getRotate() const
<span class="lineNum">     240 </span>            : {
<span class="lineNum">     241 </span>            :     ofQuaternion q;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     // From http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
<span class="lineNum">     244 </span>            :     QW = 0.5 * sqrt( osg::maximum( 0.0, 1.0 + _mat[0][0] + _mat[1][1] + _mat[2][2] ) );
<span class="lineNum">     245 </span>            :     QX = 0.5 * sqrt( osg::maximum( 0.0, 1.0 + _mat[0][0] - _mat[1][1] - _mat[2][2] ) );
<span class="lineNum">     246 </span>            :     QY = 0.5 * sqrt( osg::maximum( 0.0, 1.0 - _mat[0][0] + _mat[1][1] - _mat[2][2] ) );
<span class="lineNum">     247 </span>            :     QZ = 0.5 * sqrt( osg::maximum( 0.0, 1.0 - _mat[0][0] - _mat[1][1] + _mat[2][2] ) );
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : #if 0
<span class="lineNum">     250 </span>            :     // Robert Osfield, June 7th 2007, arggg this new implementation produces many many errors, so have to revert to sign(..) orignal below.
<span class="lineNum">     251 </span>            :     QX = QX * osg::signOrZero(  _mat[1][2] - _mat[2][1]) ;
<span class="lineNum">     252 </span>            :     QY = QY * osg::signOrZero(  _mat[2][0] - _mat[0][2]) ;
<span class="lineNum">     253 </span>            :     QZ = QZ * osg::signOrZero(  _mat[0][1] - _mat[1][0]) ;
<span class="lineNum">     254 </span>            : #else
<span class="lineNum">     255 </span>            :     QX = QX * osg::sign(  _mat[1][2] - _mat[2][1]) ;
<span class="lineNum">     256 </span>            :     QY = QY * osg::sign(  _mat[2][0] - _mat[0][2]) ;
<span class="lineNum">     257 </span>            :     QZ = QZ * osg::sign(  _mat[0][1] - _mat[1][0]) ;
<span class="lineNum">     258 </span>            : #endif
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     return q;
<span class="lineNum">     261 </span>            : }
<span class="lineNum">     262 </span>            : #endif
<span class="lineNum">     263 </span>            : 
<a name="264"><span class="lineNum">     264 </span>            : #ifdef COMPILE_getRotate_Original</a>
<span class="lineNum">     265 </span>            : // Original implementation
<span class="lineNum">     266 </span><span class="lineCov">       3869 : ofQuaternion ofMatrix4x4::getRotate() const</span>
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span><span class="lineCov">       3869 :     ofQuaternion q;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">       3869 :     ofMatrix4x4 mat = *this;</span>
<span class="lineNum">     271 </span><span class="lineCov">       3869 :     ofVec3f vs = mat.getScale();</span>
<span class="lineNum">     272 </span><span class="lineCov">       3869 :     mat.scale(1./vs.x,1./vs.y,1./vs.z);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineCov">       3869 :     ofVec4f* m = mat._mat;</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     // Source: Gamasutra, Rotating Objects Using Quaternions
<span class="lineNum">     277 </span>            :     //
<span class="lineNum">     278 </span>            :     //http://www.gamasutra.com/features/programming/19980703/quaternions_01.htm
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :     float  tr, s;
<span class="lineNum">     281 </span>            :     float tq[4];
<span class="lineNum">     282 </span>            :     int    i, j, k;
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">       3869 :     int nxt[3] = {1, 2, 0};</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineCov">       3869 :     tr = m[0][0] + m[1][1] + m[2][2]+1.0;</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     // check the diagonal
<span class="lineNum">     289 </span><span class="lineCov">       3869 :     if (tr &gt; 0.0)</span>
<span class="lineNum">     290 </span>            :     {
<span class="lineNum">     291 </span><span class="lineCov">       2246 :         s = (float)sqrt (tr);</span>
<span class="lineNum">     292 </span><span class="lineCov">       2246 :         QW = s / 2.0;</span>
<span class="lineNum">     293 </span><span class="lineCov">       2246 :         s = 0.5 / s;</span>
<span class="lineNum">     294 </span><span class="lineCov">       2246 :         QX = (m[1][2] - m[2][1]) * s;</span>
<span class="lineNum">     295 </span><span class="lineCov">       2246 :         QY = (m[2][0] - m[0][2]) * s;</span>
<span class="lineNum">     296 </span><span class="lineCov">       2246 :         QZ = (m[0][1] - m[1][0]) * s;</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            :     else
<span class="lineNum">     299 </span>            :     {
<span class="lineNum">     300 </span>            :         // diagonal is negative
<span class="lineNum">     301 </span><span class="lineCov">       1623 :         i = 0;</span>
<span class="lineNum">     302 </span><span class="lineCov">       1623 :         if (m[1][1] &gt; m[0][0])</span>
<span class="lineNum">     303 </span><span class="lineCov">       1623 :             i = 1;</span>
<span class="lineNum">     304 </span><span class="lineCov">       1623 :         if (m[2][2] &gt; m[i][i])</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :             i = 2;</span>
<span class="lineNum">     306 </span><span class="lineCov">       1623 :         j = nxt[i];</span>
<span class="lineNum">     307 </span><span class="lineCov">       1623 :         k = nxt[j];</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">       1623 :         s = (float)sqrt ((m[i][i] - (m[j][j] + m[k][k])) + 1.0);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineCov">       1623 :         tq[i] = s * 0.5;</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineCov">       1623 :         if (s != 0.0)</span>
<span class="lineNum">     314 </span><span class="lineCov">       1623 :             s = 0.5 / s;</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">       1623 :         tq[3] = (m[j][k] - m[k][j]) * s;</span>
<span class="lineNum">     317 </span><span class="lineCov">       1623 :         tq[j] = (m[i][j] + m[j][i]) * s;</span>
<span class="lineNum">     318 </span><span class="lineCov">       1623 :         tq[k] = (m[i][k] + m[k][i]) * s;</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineCov">       1623 :         QX = tq[0];</span>
<span class="lineNum">     321 </span><span class="lineCov">       1623 :         QY = tq[1];</span>
<span class="lineNum">     322 </span><span class="lineCov">       1623 :         QZ = tq[2];</span>
<span class="lineNum">     323 </span><span class="lineCov">       1623 :         QW = tq[3];</span>
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">       3869 :     return q;</span>
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : #endif
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : //int ofMatrix4x4::compare(const ofMatrix4x4&amp; m) const
<span class="lineNum">     332 </span>            : //{
<span class="lineNum">     333 </span>            : //    const ofMatrix4x4::float* lhs = reinterpret_cast&lt;const ofMatrix4x4::float*&gt;(_mat);
<span class="lineNum">     334 </span>            : //    const ofMatrix4x4::float* end_lhs = lhs+16;
<span class="lineNum">     335 </span>            : //    const ofMatrix4x4::float* rhs = reinterpret_cast&lt;const ofMatrix4x4::float*&gt;(m._mat);
<span class="lineNum">     336 </span>            : //    for(;lhs!=end_lhs;++lhs,++rhs)
<span class="lineNum">     337 </span>            : //    {
<span class="lineNum">     338 </span>            : //        if (*lhs &lt; *rhs) return -1;
<span class="lineNum">     339 </span>            : //        if (*rhs &lt; *lhs) return 1;
<span class="lineNum">     340 </span>            : //    }
<span class="lineNum">     341 </span>            : //    return 0;
<a name="342"><span class="lineNum">     342 </span>            : //}</a>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : void ofMatrix4x4::setTranslation( float tx, float ty, float tz )</span>
<span class="lineNum">     345 </span>            : {
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     _mat[3][0] = tx;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     _mat[3][1] = ty;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     _mat[3][2] = tz;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 : }</span>
<a name="350"><span class="lineNum">     350 </span>            : </a>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">      39094 : void ofMatrix4x4::setTranslation( const ofVec3f&amp; v )</span>
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span><span class="lineCov">      39094 :     _mat[3][0] = v.getPtr()[0];</span>
<span class="lineNum">     355 </span><span class="lineCov">      39094 :     _mat[3][1] = v.getPtr()[1];</span>
<span class="lineNum">     356 </span><span class="lineCov">      39094 :     _mat[3][2] = v.getPtr()[2];</span>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">      39094 : }</span></a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineCov">    4524928 : void ofMatrix4x4::makeIdentityMatrix()</span>
<span class="lineNum">     360 </span>            : {
<span class="lineNum">     361 </span><span class="lineCov">    4524928 :     SET_ROW(0,    1, 0, 0, 0 )</span>
<span class="lineNum">     362 </span><span class="lineCov">    4524928 :     SET_ROW(1,    0, 1, 0, 0 )</span>
<span class="lineNum">     363 </span><span class="lineCov">    4524928 :     SET_ROW(2,    0, 0, 1, 0 )</span>
<span class="lineNum">     364 </span><span class="lineCov">    4524928 :     SET_ROW(3,    0, 0, 0, 1 )</span>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">    4524928 : }</span></a>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineCov">      21942 : void ofMatrix4x4::makeScaleMatrix( const ofVec3f&amp; v )</span>
<span class="lineNum">     368 </span>            : {
<span class="lineNum">     369 </span><span class="lineCov">      21942 :     makeScaleMatrix(v.getPtr()[0], v.getPtr()[1], v.getPtr()[2] );</span>
<a name="370"><span class="lineNum">     370 </span><span class="lineCov">      21942 : }</span></a>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineCov">      21942 : void ofMatrix4x4::makeScaleMatrix( float x, float y, float z )</span>
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span><span class="lineCov">      21942 :     SET_ROW(0,    x, 0, 0, 0 )</span>
<span class="lineNum">     375 </span><span class="lineCov">      21942 :     SET_ROW(1,    0, y, 0, 0 )</span>
<span class="lineNum">     376 </span><span class="lineCov">      21942 :     SET_ROW(2,    0, 0, z, 0 )</span>
<span class="lineNum">     377 </span><span class="lineCov">      21942 :     SET_ROW(3,    0, 0, 0, 1 )</span>
<a name="378"><span class="lineNum">     378 </span><span class="lineCov">      21942 : }</span></a>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeTranslationMatrix( const ofVec3f&amp; v )</span>
<span class="lineNum">     381 </span>            : {
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :     makeTranslationMatrix( v.getPtr()[0], v.getPtr()[1], v.getPtr()[2] );</span></a>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeTranslationMatrix( float x, float y, float z )</span>
<span class="lineNum">     385 </span>            : {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     SET_ROW(0,    1, 0, 0, 0 )</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     SET_ROW(1,    0, 1, 0, 0 )</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     SET_ROW(2,    0, 0, 1, 0 )</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     SET_ROW(3,    x, y, z, 1 )</span>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeRotationMatrix( const ofVec3f&amp; from, const ofVec3f&amp; to )</span>
<span class="lineNum">     393 </span>            : {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     makeIdentityMatrix();</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     ofQuaternion quat;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     quat.makeRotate(from,to);</span>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :     setRotate(quat);</span></a>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeRotationMatrix( float angle, const ofVec3f&amp; axis )</span>
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     makeIdentityMatrix();</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     ofQuaternion quat;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     quat.makeRotate( angle, axis);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     setRotate(quat);</span>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeRotationMatrix( float angle, float x, float y, float z )</span>
<span class="lineNum">     410 </span>            : {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     makeIdentityMatrix();</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     ofQuaternion quat;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     quat.makeRotate( angle, x, y, z);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     setRotate(quat);</span>
<a name="416"><span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">       1909 : void ofMatrix4x4::makeRotationMatrix( const ofQuaternion&amp; quat )</span>
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span><span class="lineCov">       1909 :     makeIdentityMatrix();</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineCov">       1909 :     setRotate(quat);</span>
<a name="423"><span class="lineNum">     423 </span><span class="lineCov">       1909 : }</span></a>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeRotationMatrix( float angle1, const ofVec3f&amp; axis1,</span>
<span class="lineNum">     426 </span>            :                                                                            float angle2, const ofVec3f&amp; axis2,
<span class="lineNum">     427 </span>            :                                                                            float angle3, const ofVec3f&amp; axis3)
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     makeIdentityMatrix();</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     ofQuaternion quat;</span>
<span class="lineNum">     432 </span>            :     quat.makeRotate(angle1, axis1,
<span class="lineNum">     433 </span>            :                     angle2, axis2,
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                     angle3, axis3);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     setRotate(quat);</span>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineCov">    1501179 : void ofMatrix4x4::makeFromMultiplicationOf( const ofMatrix4x4&amp; lhs, const ofMatrix4x4&amp; rhs )</span>
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span><span class="lineCov">    1501179 :     if (&amp;lhs==this)</span>
<span class="lineNum">     441 </span>            :     {
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         postMult(rhs);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span><span class="lineCov">    1501179 :     if (&amp;rhs==this)</span>
<span class="lineNum">     446 </span>            :     {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         preMult(lhs);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :         // PRECONDITION: We assume neither &amp;lhs nor &amp;rhs == this
<span class="lineNum">     452 </span>            :         // if it did, use preMult or postMult instead
<span class="lineNum">     453 </span><span class="lineCov">    1501179 :     _mat[0][0] = INNER_PRODUCT(lhs, rhs, 0, 0);</span>
<span class="lineNum">     454 </span><span class="lineCov">    1501179 :     _mat[0][1] = INNER_PRODUCT(lhs, rhs, 0, 1);</span>
<span class="lineNum">     455 </span><span class="lineCov">    1501179 :     _mat[0][2] = INNER_PRODUCT(lhs, rhs, 0, 2);</span>
<span class="lineNum">     456 </span><span class="lineCov">    1501179 :     _mat[0][3] = INNER_PRODUCT(lhs, rhs, 0, 3);</span>
<span class="lineNum">     457 </span><span class="lineCov">    1501179 :     _mat[1][0] = INNER_PRODUCT(lhs, rhs, 1, 0);</span>
<span class="lineNum">     458 </span><span class="lineCov">    1501179 :     _mat[1][1] = INNER_PRODUCT(lhs, rhs, 1, 1);</span>
<span class="lineNum">     459 </span><span class="lineCov">    1501179 :     _mat[1][2] = INNER_PRODUCT(lhs, rhs, 1, 2);</span>
<span class="lineNum">     460 </span><span class="lineCov">    1501179 :     _mat[1][3] = INNER_PRODUCT(lhs, rhs, 1, 3);</span>
<span class="lineNum">     461 </span><span class="lineCov">    1501179 :     _mat[2][0] = INNER_PRODUCT(lhs, rhs, 2, 0);</span>
<span class="lineNum">     462 </span><span class="lineCov">    1501179 :     _mat[2][1] = INNER_PRODUCT(lhs, rhs, 2, 1);</span>
<span class="lineNum">     463 </span><span class="lineCov">    1501179 :     _mat[2][2] = INNER_PRODUCT(lhs, rhs, 2, 2);</span>
<span class="lineNum">     464 </span><span class="lineCov">    1501179 :     _mat[2][3] = INNER_PRODUCT(lhs, rhs, 2, 3);</span>
<span class="lineNum">     465 </span><span class="lineCov">    1501179 :     _mat[3][0] = INNER_PRODUCT(lhs, rhs, 3, 0);</span>
<span class="lineNum">     466 </span><span class="lineCov">    1501179 :     _mat[3][1] = INNER_PRODUCT(lhs, rhs, 3, 1);</span>
<span class="lineNum">     467 </span><span class="lineCov">    1501179 :     _mat[3][2] = INNER_PRODUCT(lhs, rhs, 3, 2);</span>
<span class="lineNum">     468 </span><span class="lineCov">    1501179 :     _mat[3][3] = INNER_PRODUCT(lhs, rhs, 3, 3);</span>
<a name="469"><span class="lineNum">     469 </span>            : }</a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 : void ofMatrix4x4::preMult( const ofMatrix4x4&amp; other )</span>
<span class="lineNum">     472 </span>            : {
<span class="lineNum">     473 </span>            :     // brute force method requiring a copy
<span class="lineNum">     474 </span>            :     //ofMatrix4x4 tmp(other* *this);
<span class="lineNum">     475 </span>            :     // *this = tmp;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :     // more efficient method just use a float[4] for temporary storage.
<span class="lineNum">     478 </span>            :     float t[4];
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     for(int col=0; col&lt;4; ++col) {</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         t[0] = INNER_PRODUCT( other, *this, 0, col );</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         t[1] = INNER_PRODUCT( other, *this, 1, col );</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         t[2] = INNER_PRODUCT( other, *this, 2, col );</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         t[3] = INNER_PRODUCT( other, *this, 3, col );</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         _mat[0][col] = t[0];</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         _mat[1][col] = t[1];</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         _mat[2][col] = t[2];</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         _mat[3][col] = t[3];</span>
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span>            : 
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">      21528 : void ofMatrix4x4::postMult( const ofMatrix4x4&amp; other )</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span>            :     // brute force method requiring a copy
<span class="lineNum">     495 </span>            :     //ofMatrix4x4 tmp(*this * other);
<span class="lineNum">     496 </span>            :     // *this = tmp;
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :     // more efficient method just use a float[4] for temporary storage.
<span class="lineNum">     499 </span>            :     float t[4];
<span class="lineNum">     500 </span><span class="lineCov">     107640 :     for(int row=0; row&lt;4; ++row)</span>
<span class="lineNum">     501 </span>            :     {
<span class="lineNum">     502 </span><span class="lineCov">      86112 :         t[0] = INNER_PRODUCT( *this, other, row, 0 );</span>
<span class="lineNum">     503 </span><span class="lineCov">      86112 :         t[1] = INNER_PRODUCT( *this, other, row, 1 );</span>
<span class="lineNum">     504 </span><span class="lineCov">      86112 :         t[2] = INNER_PRODUCT( *this, other, row, 2 );</span>
<span class="lineNum">     505 </span><span class="lineCov">      86112 :         t[3] = INNER_PRODUCT( *this, other, row, 3 );</span>
<span class="lineNum">     506 </span><span class="lineCov">      86112 :         SET_ROW(row, t[0], t[1], t[2], t[3] )</span>
<span class="lineNum">     507 </span>            :     }
<span class="lineNum">     508 </span><span class="lineCov">      21528 : }</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : #undef INNER_PRODUCT
<a name="511"><span class="lineNum">     511 </span>            : </a>
<span class="lineNum">     512 </span>            : // orthoNormalize the 3x3 rotation matrix
<span class="lineNum">     513 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeOrthoNormalOf(const ofMatrix4x4&amp; rhs)</span>
<span class="lineNum">     514 </span>            : {
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     float x_colMag = (rhs._mat[0][0] * rhs._mat[0][0]) + (rhs._mat[1][0] * rhs._mat[1][0]) + (rhs._mat[2][0] * rhs._mat[2][0]);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     float y_colMag = (rhs._mat[0][1] * rhs._mat[0][1]) + (rhs._mat[1][1] * rhs._mat[1][1]) + (rhs._mat[2][1] * rhs._mat[2][1]);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     float z_colMag = (rhs._mat[0][2] * rhs._mat[0][2]) + (rhs._mat[1][2] * rhs._mat[1][2]) + (rhs._mat[2][2] * rhs._mat[2][2]);</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     if(!equivalent((double)x_colMag, 1.0) &amp;&amp; !equivalent((double)x_colMag, 0.0))</span>
<span class="lineNum">     520 </span>            :     {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                 x_colMag = sqrt(x_colMag);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                 _mat[0][0] = rhs._mat[0][0] / x_colMag;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                 _mat[1][0] = rhs._mat[1][0] / x_colMag;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 _mat[2][0] = rhs._mat[2][0] / x_colMag;</span>
<span class="lineNum">     525 </span>            :     }
<span class="lineNum">     526 </span>            :     else
<span class="lineNum">     527 </span>            :     {
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 _mat[0][0] = rhs._mat[0][0];</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                 _mat[1][0] = rhs._mat[1][0];</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                 _mat[2][0] = rhs._mat[2][0];</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     if(!equivalent((double)y_colMag, 1.0) &amp;&amp; !equivalent((double)y_colMag, 0.0))</span>
<span class="lineNum">     534 </span>            :     {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                 y_colMag = sqrt(y_colMag);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                 _mat[0][1] = rhs._mat[0][1] / y_colMag;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                 _mat[1][1] = rhs._mat[1][1] / y_colMag;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :                 _mat[2][1] = rhs._mat[2][1] / y_colMag;</span>
<span class="lineNum">     539 </span>            :     }
<span class="lineNum">     540 </span>            :     else
<span class="lineNum">     541 </span>            :     {
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                 _mat[0][1] = rhs._mat[0][1];</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                 _mat[1][1] = rhs._mat[1][1];</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 _mat[2][1] = rhs._mat[2][1];</span>
<span class="lineNum">     545 </span>            :     }
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     if(!equivalent((double)z_colMag, 1.0) &amp;&amp; !equivalent((double)z_colMag, 0.0))</span>
<span class="lineNum">     548 </span>            :     {
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                 z_colMag = sqrt(z_colMag);</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                 _mat[0][2] = rhs._mat[0][2] / z_colMag;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                 _mat[1][2] = rhs._mat[1][2] / z_colMag;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                 _mat[2][2] = rhs._mat[2][2] / z_colMag;</span>
<span class="lineNum">     553 </span>            :     }
<span class="lineNum">     554 </span>            :     else
<span class="lineNum">     555 </span>            :     {
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                 _mat[0][2] = rhs._mat[0][2];</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                 _mat[1][2] = rhs._mat[1][2];</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 _mat[2][2] = rhs._mat[2][2];</span>
<span class="lineNum">     559 </span>            :     }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     _mat[3][0] = rhs._mat[3][0];</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     _mat[3][1] = rhs._mat[3][1];</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     _mat[3][2] = rhs._mat[3][2];</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     _mat[0][3] = rhs._mat[0][3];</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     _mat[1][3] = rhs._mat[1][3];</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     _mat[2][3] = rhs._mat[2][3];</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     _mat[3][3] = rhs._mat[3][3];</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : /** 4x3 matrix invert, not right hand column is assumed to be 0,0,0,1. */
<span class="lineNum">     574 </span>            : bool invert_4x3( const ofMatrix4x4&amp; src, ofMatrix4x4 &amp; dst);
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : /** full 4x4 matrix invert. */
<a name="577"><span class="lineNum">     577 </span>            : bool invert_4x4( const ofMatrix4x4&amp; rhs, ofMatrix4x4 &amp; dst);</a>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">    1493854 : bool ofMatrix4x4::makeInvertOf(const ofMatrix4x4 &amp; rhs){</span>
<span class="lineNum">     580 </span><span class="lineCov">    1493854 :         bool is_4x3 = (rhs._mat[0][3] == 0.0f &amp;&amp; rhs._mat[1][3] == 0.0f &amp;&amp;  rhs._mat[2][3] == 0.0f &amp;&amp; rhs._mat[3][3] == 1.0f);</span>
<span class="lineNum">     581 </span><span class="lineCov">    1493854 :         return is_4x3 ? invert_4x3(rhs,*this) :  invert_4x4(rhs,*this);</span>
<a name="582"><span class="lineNum">     582 </span>            : }</a>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineNoCov">          0 : ofMatrix4x4 ofMatrix4x4::getInverse()</span>
<span class="lineNum">     585 </span>            : {
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     ofMatrix4x4 inverse;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     inverse.makeInvertOf(*this);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     return inverse;</span>
<span class="lineNum">     589 </span>            : }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : /******************************************
<span class="lineNum">     596 </span>            :  Matrix inversion technique:
<span class="lineNum">     597 </span>            :  Given a matrix mat, we want to invert it.
<span class="lineNum">     598 </span>            :  mat = [ r00 r01 r02 a
<span class="lineNum">     599 </span>            :  r10 r11 r12 b
<span class="lineNum">     600 </span>            :  r20 r21 r22 c
<span class="lineNum">     601 </span>            :  tx  ty  tz  d ]
<span class="lineNum">     602 </span>            :  We note that this matrix can be split into three matrices.
<span class="lineNum">     603 </span>            :  mat = rot * trans * corr, where rot is rotation part, trans is translation part, and corr is the correction due to perspective (if any).
<span class="lineNum">     604 </span>            :  rot = [ r00 r01 r02 0
<span class="lineNum">     605 </span>            :  r10 r11 r12 0
<span class="lineNum">     606 </span>            :  r20 r21 r22 0
<span class="lineNum">     607 </span>            :  0   0   0   1 ]
<span class="lineNum">     608 </span>            :  trans = [ 1  0  0  0
<span class="lineNum">     609 </span>            :  0  1  0  0
<span class="lineNum">     610 </span>            :  0  0  1  0
<span class="lineNum">     611 </span>            :  tx ty tz 1 ]
<span class="lineNum">     612 </span>            :  corr = [ 1 0 0 px
<span class="lineNum">     613 </span>            :  0 1 0 py
<span class="lineNum">     614 </span>            :  0 0 1 pz
<span class="lineNum">     615 </span>            :  0 0 0 s ]
<span class="lineNum">     616 </span>            :  where the elements of corr are obtained from linear combinations of the elements of rot, trans, and mat.
<span class="lineNum">     617 </span>            :  So the inverse is mat' = (trans * corr)' * rot', where rot' must be computed the traditional way, which is easy since it is only a 3x3 matrix.
<span class="lineNum">     618 </span>            :  This problem is simplified if [px py pz s] = [0 0 0 1], which will happen if mat was composed only of rotations, scales, and translations (which is common).  In this case, we can ignore corr entirely which saves on a lot of computations.
<span class="lineNum">     619 </span>            :  ******************************************/
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineCov">    1492958 : bool invert_4x3( const ofMatrix4x4&amp; src, ofMatrix4x4 &amp; dst )</span>
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineCov">    1492958 :     if (&amp;src==&amp;dst)</span>
<span class="lineNum">     624 </span>            :     {
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                 ofMatrix4x4 tm(src);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                 return invert_4x3(tm,dst);</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     register float r00, r01, r02,
<span class="lineNum">     630 </span>            :         r10, r11, r12,
<span class="lineNum">     631 </span>            :         r20, r21, r22;
<span class="lineNum">     632 </span>            :         // Copy rotation components directly into registers for speed
<span class="lineNum">     633 </span><span class="lineCov">    1492958 :     r00 = src._mat[0][0]; r01 = src._mat[0][1]; r02 = src._mat[0][2];</span>
<span class="lineNum">     634 </span><span class="lineCov">    1492958 :     r10 = src._mat[1][0]; r11 = src._mat[1][1]; r12 = src._mat[1][2];</span>
<span class="lineNum">     635 </span><span class="lineCov">    1492958 :     r20 = src._mat[2][0]; r21 = src._mat[2][1]; r22 = src._mat[2][2];</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         // Partially compute inverse of rot
<span class="lineNum">     638 </span><span class="lineCov">    1492958 :     dst._mat[0][0] = r11*r22 - r12*r21;</span>
<span class="lineNum">     639 </span><span class="lineCov">    1492958 :     dst._mat[0][1] = r02*r21 - r01*r22;</span>
<span class="lineNum">     640 </span><span class="lineCov">    1492958 :     dst._mat[0][2] = r01*r12 - r02*r11;</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :         // Compute determinant of rot from 3 elements just computed
<span class="lineNum">     643 </span><span class="lineCov">    1492958 :     register float one_over_det = 1.0/(r00*dst._mat[0][0] + r10*dst._mat[0][1] + r20*dst._mat[0][2]);</span>
<span class="lineNum">     644 </span><span class="lineCov">    1492958 :     r00 *= one_over_det; r10 *= one_over_det; r20 *= one_over_det;  // Saves on later computations</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :         // Finish computing inverse of rot
<span class="lineNum">     647 </span><span class="lineCov">    1492958 :     dst._mat[0][0] *= one_over_det;</span>
<span class="lineNum">     648 </span><span class="lineCov">    1492958 :     dst._mat[0][1] *= one_over_det;</span>
<span class="lineNum">     649 </span><span class="lineCov">    1492958 :     dst._mat[0][2] *= one_over_det;</span>
<span class="lineNum">     650 </span><span class="lineCov">    1492958 :     dst._mat[0][3] = 0.0;</span>
<span class="lineNum">     651 </span><span class="lineCov">    1492958 :     dst._mat[1][0] = r12*r20 - r10*r22; // Have already been divided by det</span>
<span class="lineNum">     652 </span><span class="lineCov">    1492958 :     dst._mat[1][1] = r00*r22 - r02*r20; // same</span>
<span class="lineNum">     653 </span><span class="lineCov">    1492958 :     dst._mat[1][2] = r02*r10 - r00*r12; // same</span>
<span class="lineNum">     654 </span><span class="lineCov">    1492958 :     dst._mat[1][3] = 0.0;</span>
<span class="lineNum">     655 </span><span class="lineCov">    1492958 :     dst._mat[2][0] = r10*r21 - r11*r20; // Have already been divided by det</span>
<span class="lineNum">     656 </span><span class="lineCov">    1492958 :     dst._mat[2][1] = r01*r20 - r00*r21; // same</span>
<span class="lineNum">     657 </span><span class="lineCov">    1492958 :     dst._mat[2][2] = r00*r11 - r01*r10; // same</span>
<span class="lineNum">     658 </span><span class="lineCov">    1492958 :     dst._mat[2][3] = 0.0;</span>
<span class="lineNum">     659 </span><span class="lineCov">    1492958 :     dst._mat[3][3] = 1.0;</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :         // We no longer need the rxx or det variables anymore, so we can reuse them for whatever we want.  But we will still rename them for the sake of clarity.
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : #define d r22
<span class="lineNum">     664 </span><span class="lineCov">    1492958 :     d  = src._mat[3][3];</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineCov">    1492958 :     if( square(d-1.0) &gt; 1.0e-6 )  // Involves perspective, so we must</span>
<span class="lineNum">     667 </span>            :     {                       // compute the full inverse
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         ofMatrix4x4 TPinv;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :         dst._mat[3][0] = dst._mat[3][1] = dst._mat[3][2] = 0.0;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : #define px r00
<span class="lineNum">     673 </span>            : #define py r01
<span class="lineNum">     674 </span>            : #define pz r02
<span class="lineNum">     675 </span>            : #define one_over_s  one_over_det
<span class="lineNum">     676 </span>            : #define a  r10
<span class="lineNum">     677 </span>            : #define b  r11
<span class="lineNum">     678 </span>            : #define c  r12
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         a  = src._mat[0][3]; b  = src._mat[1][3]; c  = src._mat[2][3];</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         px = dst._mat[0][0]*a + dst._mat[0][1]*b + dst._mat[0][2]*c;</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         py = dst._mat[1][0]*a + dst._mat[1][1]*b + dst._mat[1][2]*c;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         pz = dst._mat[2][0]*a + dst._mat[2][1]*b + dst._mat[2][2]*c;</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            : #undef a
<span class="lineNum">     686 </span>            : #undef b
<span class="lineNum">     687 </span>            : #undef c
<span class="lineNum">     688 </span>            : #define tx r10
<span class="lineNum">     689 </span>            : #define ty r11
<span class="lineNum">     690 </span>            : #define tz r12
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         tx = src._mat[3][0]; ty = src._mat[3][1]; tz = src._mat[3][2];</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         one_over_s  = 1.0/(d - (tx*px + ty*py + tz*pz));</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         tx *= one_over_s; ty *= one_over_s; tz *= one_over_s;  // Reduces number of calculations later on</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :         // Compute inverse of trans*corr
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         TPinv._mat[0][0] = tx*px + 1.0;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         TPinv._mat[0][1] = ty*px;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         TPinv._mat[0][2] = tz*px;</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         TPinv._mat[0][3] = -px * one_over_s;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         TPinv._mat[1][0] = tx*py;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         TPinv._mat[1][1] = ty*py + 1.0;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :         TPinv._mat[1][2] = tz*py;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         TPinv._mat[1][3] = -py * one_over_s;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         TPinv._mat[2][0] = tx*pz;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         TPinv._mat[2][1] = ty*pz;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         TPinv._mat[2][2] = tz*pz + 1.0;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         TPinv._mat[2][3] = -pz * one_over_s;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         TPinv._mat[3][0] = -tx;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         TPinv._mat[3][1] = -ty;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         TPinv._mat[3][2] = -tz;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         TPinv._mat[3][3] = one_over_s;</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         dst.preMult(TPinv); // Finish computing full inverse of mat</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : #undef px
<span class="lineNum">     718 </span>            : #undef py
<span class="lineNum">     719 </span>            : #undef pz
<span class="lineNum">     720 </span>            : #undef one_over_s
<span class="lineNum">     721 </span>            : #undef d
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span>            :     else // Rightmost column is [0; 0; 0; 1] so it can be ignored
<span class="lineNum">     724 </span>            :     {
<span class="lineNum">     725 </span><span class="lineCov">    1492958 :         tx = src._mat[3][0]; ty = src._mat[3][1]; tz = src._mat[3][2];</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :         // Compute translation components of mat'
<span class="lineNum">     728 </span><span class="lineCov">    1492958 :         dst._mat[3][0] = -(tx*dst._mat[0][0] + ty*dst._mat[1][0] + tz*dst._mat[2][0]);</span>
<span class="lineNum">     729 </span><span class="lineCov">    1492958 :         dst._mat[3][1] = -(tx*dst._mat[0][1] + ty*dst._mat[1][1] + tz*dst._mat[2][1]);</span>
<span class="lineNum">     730 </span><span class="lineCov">    1492958 :         dst._mat[3][2] = -(tx*dst._mat[0][2] + ty*dst._mat[1][2] + tz*dst._mat[2][2]);</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : #undef tx
<span class="lineNum">     733 </span>            : #undef ty
<span class="lineNum">     734 </span>            : #undef tz
<span class="lineNum">     735 </span>            :     }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">    1492958 :     return true;</span>
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : 
<a name="740"><span class="lineNum">     740 </span>            : </a>
<span class="lineNum">     741 </span>            : template &lt;class T&gt;
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">      32678 : inline T SGL_ABS(T a)</span></a>
<span class="lineNum">     743 </span>            : {
<span class="lineNum">     744 </span><span class="lineCov">      32678 :         return (a &gt;= 0 ? a : -a);</span>
<span class="lineNum">     745 </span>            : }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : #ifndef SGL_SWAP
<span class="lineNum">     748 </span>            : #define SGL_SWAP(a,b,temp) ((temp)=(a),(a)=(b),(b)=(temp))
<span class="lineNum">     749 </span>            : #endif
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineCov">        896 : bool invert_4x4( const ofMatrix4x4&amp; src, ofMatrix4x4&amp;dst )</span>
<span class="lineNum">     752 </span>            : {
<span class="lineNum">     753 </span><span class="lineCov">        896 :     if (&amp;src==&amp;dst) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :                 ofMatrix4x4 tm(src);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :                 return invert_4x4(tm,dst);</span>
<span class="lineNum">     756 </span>            :     }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :     unsigned int indxc[4], indxr[4], ipiv[4];
<span class="lineNum">     759 </span>            :     unsigned int i,j,k,l,ll;
<span class="lineNum">     760 </span><span class="lineCov">        896 :     unsigned int icol = 0;</span>
<span class="lineNum">     761 </span><span class="lineCov">        896 :     unsigned int irow = 0;</span>
<span class="lineNum">     762 </span>            :     double temp, pivinv, dum, big;
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     // copy in place this may be unnecessary
<span class="lineNum">     765 </span><span class="lineCov">        896 :     dst = src;</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineCov">       4480 :     for (j=0; j&lt;4; j++) ipiv[j]=0;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">       4480 :     for(i=0;i&lt;4;i++)</span>
<span class="lineNum">     770 </span>            :     {
<span class="lineNum">     771 </span><span class="lineCov">       3584 :                 big=0.0;</span>
<span class="lineNum">     772 </span><span class="lineCov">      17920 :                 for (j=0; j&lt;4; j++)</span>
<span class="lineNum">     773 </span><span class="lineCov">      14336 :                         if (ipiv[j] != 1)</span>
<span class="lineNum">     774 </span><span class="lineCov">      44800 :                                 for (k=0; k&lt;4; k++)</span>
<span class="lineNum">     775 </span>            :                                 {
<span class="lineNum">     776 </span><span class="lineCov">      35840 :                                         if (ipiv[k] == 0)</span>
<span class="lineNum">     777 </span>            :                                         {
<span class="lineNum">     778 </span><span class="lineCov">      26880 :                                                 if (SGL_ABS(dst(j,k)) &gt;= big)</span>
<span class="lineNum">     779 </span>            :                                                 {
<span class="lineNum">     780 </span><span class="lineCov">       5798 :                                                         big = SGL_ABS(dst(j,k));</span>
<span class="lineNum">     781 </span><span class="lineCov">       5798 :                                                         irow=j;</span>
<span class="lineNum">     782 </span><span class="lineCov">       5798 :                                                         icol=k;</span>
<span class="lineNum">     783 </span>            :                                                 }
<span class="lineNum">     784 </span>            :                                         }
<span class="lineNum">     785 </span><span class="lineCov">       8960 :                                         else if (ipiv[k] &gt; 1)</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                                                 return false;</span>
<span class="lineNum">     787 </span>            :                                 }
<span class="lineNum">     788 </span><span class="lineCov">       3584 :                 ++(ipiv[icol]);</span>
<span class="lineNum">     789 </span><span class="lineCov">       3584 :                 if (irow != icol)</span>
<span class="lineNum">     790 </span><span class="lineCov">        480 :                         for (l=0; l&lt;4; l++) SGL_SWAP(dst(irow,l),</span>
<span class="lineNum">     791 </span>            :                                                                                  dst(icol,l),
<span class="lineNum">     792 </span><span class="lineCov">       1152 :                                                                                  temp);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineCov">       3584 :                 indxr[i]=irow;</span>
<span class="lineNum">     795 </span><span class="lineCov">       3584 :                 indxc[i]=icol;</span>
<span class="lineNum">     796 </span><span class="lineCov">       3584 :                 if (dst(icol,icol) == 0)</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">       3584 :                 pivinv = 1.0/dst(icol,icol);</span>
<span class="lineNum">     800 </span><span class="lineCov">       3584 :                 dst(icol,icol) = 1;</span>
<span class="lineNum">     801 </span><span class="lineCov">      17920 :                 for (l=0; l&lt;4; l++) dst(icol,l) *= pivinv;</span>
<span class="lineNum">     802 </span><span class="lineCov">      17920 :                 for (ll=0; ll&lt;4; ll++)</span>
<span class="lineNum">     803 </span><span class="lineCov">      14336 :                         if (ll != icol)</span>
<span class="lineNum">     804 </span>            :                         {
<span class="lineNum">     805 </span><span class="lineCov">      10752 :                                 dum=dst(ll,icol);</span>
<span class="lineNum">     806 </span><span class="lineCov">      10752 :                                 dst(ll,icol) = 0;</span>
<span class="lineNum">     807 </span><span class="lineCov">      53760 :                                 for (l=0; l&lt;4; l++)dst(ll,l) -= dst(icol,l)*dum;</span>
<span class="lineNum">     808 </span>            :                         }
<span class="lineNum">     809 </span>            :     }
<span class="lineNum">     810 </span><span class="lineCov">       4480 :     for (int lx=4; lx&gt;0; --lx)</span>
<span class="lineNum">     811 </span>            :     {
<span class="lineNum">     812 </span><span class="lineCov">       3584 :                 if (indxr[lx-1] != indxc[lx-1])</span>
<span class="lineNum">     813 </span><span class="lineCov">        480 :                         for (k=0; k&lt;4; k++) SGL_SWAP(dst(k,indxr[lx-1]),</span>
<span class="lineNum">     814 </span><span class="lineCov">       1152 :                                                                                  dst(k,indxc[lx-1]),temp);</span>
<span class="lineNum">     815 </span>            :     }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span><span class="lineCov">        896 :     return true;</span>
<a name="818"><span class="lineNum">     818 </span>            : }</a>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeOrthoMatrix(double left, double right,</span>
<span class="lineNum">     821 </span>            :                                                                           double bottom, double top,
<span class="lineNum">     822 </span>            :                                                                           double zNear, double zFar)
<span class="lineNum">     823 </span>            : {
<span class="lineNum">     824 </span>            :     // note transpose of ofMatrix4x4 wr.t OpenGL documentation, since the OSG use post multiplication rather than pre.
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     double tx = -(right+left)/(right-left);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     double ty = -(top+bottom)/(top-bottom);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     double tz = -(zFar+zNear)/(zFar-zNear);</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     SET_ROW(0, 2.0/(right-left),               0.0,               0.0, 0.0 )</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     SET_ROW(1,              0.0,  2.0/(top-bottom),               0.0, 0.0 )</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     SET_ROW(2,              0.0,               0.0,  -2.0/(zFar-zNear), 0.0 )</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     SET_ROW(3,               tx,                ty,                 tz, 1.0 )</span>
<a name="832"><span class="lineNum">     832 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineNoCov">          0 : bool ofMatrix4x4::getOrtho(double&amp; left, double&amp; right,</span>
<span class="lineNum">     835 </span>            :                                                                          double&amp; bottom, double&amp; top,
<span class="lineNum">     836 </span>            :                                                                          double&amp; zNear, double&amp; zFar) const
<span class="lineNum">     837 </span>            : {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     if (_mat[0][3]!=0.0 || _mat[1][3]!=0.0 || _mat[2][3]!=0.0 || _mat[3][3]!=1.0) return false;</span>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     zNear = (_mat[3][2]+1.0) / _mat[2][2];</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     zFar = (_mat[3][2]-1.0) / _mat[2][2];</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     left = -(1.0+_mat[3][0]) / _mat[0][0];</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     right = (1.0-_mat[3][0]) / _mat[0][0];</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     bottom = -(1.0+_mat[3][1]) / _mat[1][1];</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     top = (1.0-_mat[3][1]) / _mat[1][1];</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     850 </span>            : }
<a name="851"><span class="lineNum">     851 </span>            : </a>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineCov">    1481084 : void ofMatrix4x4::makeFrustumMatrix(double left, double right,</span>
<span class="lineNum">     854 </span>            :                                                                                 double bottom, double top,
<span class="lineNum">     855 </span>            :                                                                                 double zNear, double zFar)
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span>            :     // note transpose of ofMatrix4x4 wr.t OpenGL documentation, since the OSG use post multiplication rather than pre.
<span class="lineNum">     858 </span><span class="lineCov">    1481084 :     double A = (right+left)/(right-left);</span>
<span class="lineNum">     859 </span><span class="lineCov">    1481084 :     double B = (top+bottom)/(top-bottom);</span>
<span class="lineNum">     860 </span><span class="lineCov">    1481084 :     double C = -(zFar+zNear)/(zFar-zNear);</span>
<span class="lineNum">     861 </span><span class="lineCov">    1481084 :     double D = -2.0*zFar*zNear/(zFar-zNear);</span>
<span class="lineNum">     862 </span><span class="lineCov">    1481084 :     SET_ROW(0, 2.0*zNear/(right-left),                    0.0, 0.0,  0.0 )</span>
<span class="lineNum">     863 </span><span class="lineCov">    1481084 :     SET_ROW(1,                    0.0, 2.0*zNear/(top-bottom), 0.0,  0.0 )</span>
<span class="lineNum">     864 </span><span class="lineCov">    1481084 :     SET_ROW(2,                      A,                      B,   C, -1.0 )</span>
<span class="lineNum">     865 </span><span class="lineCov">    1481084 :     SET_ROW(3,                    0.0,                    0.0,   D,  0.0 )</span>
<a name="866"><span class="lineNum">     866 </span><span class="lineCov">    1481084 : }</span></a>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 : bool ofMatrix4x4::getFrustum(double&amp; left, double&amp; right,</span>
<span class="lineNum">     869 </span>            :                                        double&amp; bottom, double&amp; top,
<span class="lineNum">     870 </span>            :                                        double&amp; zNear, double&amp; zFar) const
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     if (_mat[0][3]!=0.0 || _mat[1][3]!=0.0 || _mat[2][3]!=-1.0 || _mat[3][3]!=0.0) return false;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     zNear = _mat[3][2] / (_mat[2][2]-1.0);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     zFar = _mat[3][2] / (1.0+_mat[2][2]);</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     left = zNear * (_mat[2][0]-1.0) / _mat[0][0];</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     right = zNear * (1.0+_mat[2][0]) / _mat[0][0];</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     top = zNear * (1.0+_mat[2][1]) / _mat[1][1];</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     bottom = zNear * (_mat[2][1]-1.0) / _mat[1][1];</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     885 </span>            : }
<a name="886"><span class="lineNum">     886 </span>            : </a>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineCov">    1481084 : void ofMatrix4x4::makePerspectiveMatrix(double fovy,double aspectRatio,</span>
<span class="lineNum">     889 </span>            :                                             double zNear, double zFar)
<span class="lineNum">     890 </span>            : {
<span class="lineNum">     891 </span>            :     // calculate the appropriate left, right etc.
<span class="lineNum">     892 </span><span class="lineCov">    1481084 :     double tan_fovy = tan(fovy*0.5*DEG_TO_RAD);</span>
<span class="lineNum">     893 </span><span class="lineCov">    1481084 :     double right  =  tan_fovy * aspectRatio * zNear;</span>
<span class="lineNum">     894 </span><span class="lineCov">    1481084 :     double left   = -right;</span>
<span class="lineNum">     895 </span><span class="lineCov">    1481084 :     double top    =  tan_fovy * zNear;</span>
<span class="lineNum">     896 </span><span class="lineCov">    1481084 :     double bottom =  -top;</span>
<span class="lineNum">     897 </span><span class="lineCov">    1481084 :     makeFrustumMatrix(left,right,bottom,top,zNear,zFar);</span>
<a name="898"><span class="lineNum">     898 </span><span class="lineCov">    1481084 : }</span></a>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 : bool ofMatrix4x4::getPerspective(double&amp; fovy,double&amp; aspectRatio,</span>
<span class="lineNum">     901 </span>            :                                            double&amp; zNear, double&amp; zFar) const
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     double right  =  0.0;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     double left   =  0.0;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     double top    =  0.0;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     double bottom =  0.0;</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     if (getFrustum(left,right,bottom,top,zNear,zFar))</span>
<span class="lineNum">     908 </span>            :     {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :         fovy = (atan(top/zNear)-atan(bottom/zNear))*RAD_TO_DEG;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         aspectRatio = (right-left)/(top-bottom);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="914"><span class="lineNum">     914 </span>            : }</a>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeLookAtViewMatrix(const ofVec3f&amp; eye,const ofVec3f&amp; center,const ofVec3f&amp; up)</span>
<span class="lineNum">     917 </span>            : {
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         ofVec3f zaxis = (eye - center).normalized();</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :         ofVec3f xaxis = up.getCrossed(zaxis).normalized();</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         ofVec3f yaxis = zaxis.getCrossed(xaxis);</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         _mat[0].set(xaxis.x, yaxis.x, zaxis.x, 0);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         _mat[1].set(xaxis.y, yaxis.y, zaxis.y, 0);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         _mat[2].set(xaxis.z, yaxis.z, zaxis.z, 0);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         _mat[3].set(-xaxis.dot(eye), -yaxis.dot(eye), -zaxis.dot(eye), 1);</span>
<a name="926"><span class="lineNum">     926 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 : void ofMatrix4x4::makeLookAtMatrix(const ofVec3f&amp; eye,const ofVec3f&amp; center,const ofVec3f&amp; up)</span>
<span class="lineNum">     929 </span>            : {
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         ofVec3f zaxis = (eye - center).normalized();</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         ofVec3f xaxis = up.getCrossed(zaxis).normalized();</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         ofVec3f yaxis = zaxis.getCrossed(xaxis);</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         _mat[0].set(xaxis.x, xaxis.y, xaxis.z, 0);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         _mat[1].set(yaxis.x, yaxis.y, yaxis.z, 0);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         _mat[2].set(zaxis.x, zaxis.y, zaxis.z, 0);</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         _mat[3] = eye;</span>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 : void ofMatrix4x4::getLookAt(ofVec3f&amp; eye,ofVec3f&amp; center,ofVec3f&amp; up,float lookDistance) const</span>
<span class="lineNum">     941 </span>            : {
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     ofMatrix4x4 inv;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     inv.makeInvertOf(*this);</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     eye = ofVec3f(0.0,0.0,0.0)*inv;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     up = transform3x3(*this,ofVec3f(0.0,1.0,0.0));</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     center = transform3x3(*this,ofVec3f(0.0,0.0,-1));</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     center.normalize();</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     center = eye + center*lookDistance;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : typedef ofQuaternion HVect;
<span class="lineNum">     954 </span>            : typedef double _HMatrix[4][4];
<span class="lineNum">     955 </span>            : typedef struct
<span class="lineNum">     956 </span>            : {
<span class="lineNum">     957 </span>            :         ofVec4f t;     // Translation Component;
<span class="lineNum">     958 </span>            :         ofQuaternion q;           // Essential Rotation
<span class="lineNum">     959 </span>            :         ofQuaternion u;          //Stretch rotation
<a name="960"><span class="lineNum">     960 </span>            :         HVect k;          //Sign of determinant</a>
<span class="lineNum">     961 </span>            :         double f;          // Sign of determinant
<span class="lineNum">     962 </span><span class="lineNoCov">          0 : } _affineParts;</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : enum QuatPart {X, Y, Z, W};
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : #define SQRTHALF (0.7071067811865475244)
<span class="lineNum">     968 </span><span class="lineCov">        191 : static ofQuaternion qxtoz(0,SQRTHALF,0,SQRTHALF);</span>
<span class="lineNum">     969 </span><span class="lineCov">        191 : static ofQuaternion qytoz(SQRTHALF,0,0,SQRTHALF);</span>
<span class="lineNum">     970 </span><span class="lineCov">        191 : static ofQuaternion qppmm( 0.5, 0.5,-0.5,-0.5);</span>
<span class="lineNum">     971 </span><span class="lineCov">        191 : static ofQuaternion qpppp( 0.5, 0.5, 0.5, 0.5);</span>
<span class="lineNum">     972 </span><span class="lineCov">        191 : static ofQuaternion qmpmm(-0.5, 0.5,-0.5,-0.5);</span>
<span class="lineNum">     973 </span><span class="lineCov">        191 : static ofQuaternion qpppm( 0.5, 0.5, 0.5,-0.5);</span>
<span class="lineNum">     974 </span><span class="lineCov">        191 : static ofQuaternion q0001( 0.0, 0.0, 0.0, 1.0);</span>
<span class="lineNum">     975 </span><span class="lineCov">        191 : static ofQuaternion q1000( 1.0, 0.0, 0.0, 0.0);</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : /** Copy nxn matrix A to C using &quot;gets&quot; for assignment **/
<span class="lineNum">     978 </span>            : #define matrixCopy(C, gets, A, n) {int i, j; for (i=0;i&lt;n;i++) for (j=0;j&lt;n;j++)\
<span class="lineNum">     979 </span>            :     C[i][j] gets (A[i][j]);}
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            : /** Copy transpose of nxn matrix A to C using &quot;gets&quot; for assignment **/
<span class="lineNum">     982 </span>            : #define mat_tpose(AT,gets,A,n) {int i,j; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++)\
<span class="lineNum">     983 </span>            :     AT[i][j] gets (A[j][i]);}
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : /** Fill out 3x3 matrix to 4x4 **/
<span class="lineNum">     986 </span>            : #define mat_pad(A) (A[W][X]=A[X][W]=A[W][Y]=A[Y][W]=A[W][Z]=A[Z][W]=0,A[W][W]=1)
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : /** Assign nxn matrix C the element-wise combination of A and B using &quot;op&quot; **/
<span class="lineNum">     990 </span>            : #define matBinop(C,gets,A,op,B,n) {int i,j; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++)\
<span class="lineNum">     991 </span>            :     C[i][j] gets (A[i][j]) op (B[i][j]);}
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            : /** Copy nxn matrix A to C using &quot;gets&quot; for assignment **/
<span class="lineNum">     994 </span>            : #define mat_copy(C,gets,A,n) {int i,j; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++)\
<span class="lineNum">     995 </span>            :     C[i][j] gets (A[i][j]);}
<a name="996"><span class="lineNum">     996 </span>            : </a>
<span class="lineNum">     997 </span>            : /** Multiply the upper left 3x3 parts of A and B to get AB **/
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : void mat_mult(_HMatrix A, _HMatrix B, _HMatrix AB)</span>
<span class="lineNum">     999 </span>            : {
<span class="lineNum">    1000 </span>            :     int i, j;
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) for (j=0; j&lt;3; j++)</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         AB[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + A[i][2]*B[2][j];</span>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 : double mat_norm(_HMatrix M, int tpose)</span>
<span class="lineNum">    1006 </span>            : {
<span class="lineNum">    1007 </span>            :     int i;
<span class="lineNum">    1008 </span>            :     double sum, max;
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     max = 0.0;</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) {</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         if (tpose) sum = fabs(M[0][i])+fabs(M[1][i])+fabs(M[2][i]);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         else       sum = fabs(M[i][0])+fabs(M[i][1])+fabs(M[i][2]);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         if (max&lt;sum) max = sum;</span>
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     return max;</span>
<a name="1016"><span class="lineNum">    1016 </span>            : }</a>
<a name="1017"><span class="lineNum">    1017 </span>            : </a>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 : double norm_inf(_HMatrix M) {return mat_norm(M, 0);}</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 : double norm_one(_HMatrix M) {return mat_norm(M, 1);}</span>
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            : static _HMatrix mat_id = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};
<a name="1022"><span class="lineNum">    1022 </span>            : </a>
<span class="lineNum">    1023 </span>            : /** Return index of column of M containing maximum abs entry, or -1 if M=0 **/
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 : int find_max_col(_HMatrix M)</span>
<span class="lineNum">    1025 </span>            : {
<span class="lineNum">    1026 </span>            :     double abs, max;
<span class="lineNum">    1027 </span>            :     int i, j, col;
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     max = 0.0; col = -1;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) for (j=0; j&lt;3; j++) {</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         abs = M[i][j]; if (abs&lt;0.0) abs = -abs;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         if (abs&gt;max) {max = abs; col = j;}</span>
<span class="lineNum">    1032 </span>            :     }
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     return col;</span>
<a name="1034"><span class="lineNum">    1034 </span>            : }</a>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 : void vcross(double *va, double *vb, double *v)</span>
<span class="lineNum">    1037 </span>            : {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     v[0] = va[1]*vb[2] - va[2]*vb[1];</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     v[1] = va[2]*vb[0] - va[0]*vb[2];</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     v[2] = va[0]*vb[1] - va[1]*vb[0];</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 : }</span>
<a name="1042"><span class="lineNum">    1042 </span>            : </a>
<span class="lineNum">    1043 </span>            : /** Return dot product of length 3 vectors va and vb **/
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 : double vdot(double *va, double *vb)</span>
<span class="lineNum">    1045 </span>            : {
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     return (va[0]*vb[0] + va[1]*vb[1] + va[2]*vb[2]);</span>
<span class="lineNum">    1047 </span>            : }
<span class="lineNum">    1048 </span>            : 
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<span class="lineNum">    1050 </span>            : /** Set MadjT to transpose of inverse of M times determinant of M **/
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 : void adjoint_transpose(_HMatrix M, _HMatrix MadjT)</span>
<span class="lineNum">    1052 </span>            : {
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     vcross(M[1], M[2], MadjT[0]);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     vcross(M[2], M[0], MadjT[1]);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     vcross(M[0], M[1], MadjT[2]);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 : }</span>
<a name="1057"><span class="lineNum">    1057 </span>            : </a>
<span class="lineNum">    1058 </span>            : /** Setup u for Household reflection to zero all v components but first **/
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : void make_reflector(double *v, double *u)</span>
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     double s = sqrt(vdot(v, v));</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     u[0] = v[0]; u[1] = v[1];</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     u[2] = v[2] + ((v[2]&lt;0.0) ? -s : s);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     s = sqrt(2.0/vdot(u, u));</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     u[0] = u[0]*s; u[1] = u[1]*s; u[2] = u[2]*s;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 : }</span>
<a name="1067"><span class="lineNum">    1067 </span>            : </a>
<span class="lineNum">    1068 </span>            : /** Apply Householder reflection represented by u to column vectors of M **/
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 : void reflect_cols(_HMatrix M, double *u)</span>
<span class="lineNum">    1070 </span>            : {
<span class="lineNum">    1071 </span>            :     int i, j;
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) {</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         double s = u[0]*M[0][i] + u[1]*M[1][i] + u[2]*M[2][i];</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         for (j=0; j&lt;3; j++) M[j][i] -= u[j]*s;</span>
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 : }</span>
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<span class="lineNum">    1078 </span>            : /** Apply Householder reflection represented by u to row vectors of M **/
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 : void reflect_rows(_HMatrix M, double *u)</span>
<span class="lineNum">    1080 </span>            : {
<span class="lineNum">    1081 </span>            :     int i, j;
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     for (i=0; i&lt;3; i++) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         double s = vdot(u, M[i]);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         for (j=0; j&lt;3; j++) M[i][j] -= u[j]*s;</span>
<span class="lineNum">    1085 </span>            :     }
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : }</span>
<a name="1087"><span class="lineNum">    1087 </span>            : </a>
<span class="lineNum">    1088 </span>            : /** Find orthogonal factor Q of rank 1 (or less) M **/
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 : void do_rank1(_HMatrix M, _HMatrix Q)</span>
<span class="lineNum">    1090 </span>            : {
<span class="lineNum">    1091 </span>            :     double v1[3], v2[3], s;
<span class="lineNum">    1092 </span>            :     int col;
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     mat_copy(Q,=,mat_id,4);</span>
<span class="lineNum">    1094 </span>            :     /* If rank(M) is 1, we should find a non-zero column in M */
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     col = find_max_col(M);</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     if (col&lt;0) return; /* Rank is 0 */</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     v1[0] = M[0][col]; v1[1] = M[1][col]; v1[2] = M[2][col];</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     make_reflector(v1, v1); reflect_cols(M, v1);</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     v2[0] = M[2][0]; v2[1] = M[2][1]; v2[2] = M[2][2];</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     make_reflector(v2, v2); reflect_rows(M, v2);</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     s = M[2][2];</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     if (s&lt;0.0) Q[2][2] = -1.0;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     reflect_cols(Q, v1); reflect_rows(Q, v2);</span>
<span class="lineNum">    1104 </span>            : }
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<span class="lineNum">    1106 </span>            : /** Find orthogonal factor Q of rank 2 (or less) M using adjoint transpose **/
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 : void do_rank2(_HMatrix M, _HMatrix MadjT, _HMatrix Q)</span>
<span class="lineNum">    1108 </span>            : {
<span class="lineNum">    1109 </span>            :     double v1[3], v2[3];
<span class="lineNum">    1110 </span>            :     double w, x, y, z, c, s, d;
<span class="lineNum">    1111 </span>            :     int col;
<span class="lineNum">    1112 </span>            :     /* If rank(M) is 2, we should find a non-zero column in MadjT */
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     col = find_max_col(MadjT);</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     if (col&lt;0) {do_rank1(M, Q); return;} /* Rank&lt;2 */</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     v1[0] = MadjT[0][col]; v1[1] = MadjT[1][col]; v1[2] = MadjT[2][col];</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     make_reflector(v1, v1); reflect_cols(M, v1);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     vcross(M[0], M[1], v2);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     make_reflector(v2, v2); reflect_rows(M, v2);</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     w = M[0][0]; x = M[0][1]; y = M[1][0]; z = M[1][1];</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     if (w*z&gt;x*y) {</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         c = z+w; s = y-x; d = sqrt(c*c+s*s); c = c/d; s = s/d;</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :         Q[0][0] = Q[1][1] = c; Q[0][1] = -(Q[1][0] = s);</span>
<span class="lineNum">    1123 </span>            :     } else {
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :         c = z-w; s = y+x; d = sqrt(c*c+s*s); c = c/d; s = s/d;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :         Q[0][0] = -(Q[1][1] = c); Q[0][1] = Q[1][0] = s;</span>
<span class="lineNum">    1126 </span>            :     }
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     Q[0][2] = Q[2][0] = Q[1][2] = Q[2][1] = 0.0; Q[2][2] = 1.0;</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     reflect_cols(Q, v1); reflect_rows(Q, v2);</span>
<span class="lineNum">    1129 </span>            : }
<a name="1130"><span class="lineNum">    1130 </span>            : </a>
<span class="lineNum">    1131 </span>            : /* Return product of quaternion q by scalar w. */
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 : ofQuaternion Qt_Scale(ofQuaternion q, double w)</span>
<span class="lineNum">    1133 </span>            : {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         ofQuaternion qq;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :         qq.w() = q.w()*w;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         qq.x() = q.x()*w;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         qq.y() = q.y()*w;</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         qq.z() = q.z()*w;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         return (qq);</span>
<span class="lineNum">    1140 </span>            : }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : /* Construct a unit quaternion from rotation matrix.  Assumes matrix is
<span class="lineNum">    1143 </span>            : * used to multiply column vector on the left: vnew = mat vold.  Works
<span class="lineNum">    1144 </span>            : * correctly for right-handed coordinate system and right-handed rotations.
<a name="1145"><span class="lineNum">    1145 </span>            : * Translation and perspective components ignored. */</a>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 : ofQuaternion quatFromMatrix(_HMatrix mat)</span>
<span class="lineNum">    1148 </span>            : {
<span class="lineNum">    1149 </span>            :    /* This algorithm avoids near-zero divides by looking for a large component
<span class="lineNum">    1150 </span>            :         * - first w, then x, y, or z.  When the trace is greater than zero,
<span class="lineNum">    1151 </span>            :         * |w| is greater than 1/2, which is as small as a largest component can be.
<span class="lineNum">    1152 </span>            :         * Otherwise, the largest diagonal entry corresponds to the largest of |x|,
<span class="lineNum">    1153 </span>            :         * |y|, or |z|, one of which must be larger than |w|, and at least 1/2. */
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :    ofQuaternion qu = q0001;</span>
<span class="lineNum">    1155 </span>            :    double tr, s;
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :    tr = mat[X][X] + mat[Y][Y]+ mat[Z][Z];</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :    if (tr &gt;= 0.0)</span>
<span class="lineNum">    1159 </span>            :    {
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :            s = sqrt(tr + mat[W][W]);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :            qu.w() = s*0.5;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :            s = 0.5 / s;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :            qu.x() = (mat[Z][Y] - mat[Y][Z]) * s;</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :            qu.y() = (mat[X][Z] - mat[Z][X]) * s;</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :            qu.z() = (mat[Y][X] - mat[X][Y]) * s;</span>
<span class="lineNum">    1166 </span>            :    }
<span class="lineNum">    1167 </span>            :    else
<span class="lineNum">    1168 </span>            :    {
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :            int h = X;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :            if (mat[Y][Y] &gt; mat[X][X]) h = Y;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :            if (mat[Z][Z] &gt; mat[h][h]) h = Z;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :            switch (h) {</span>
<span class="lineNum">    1173 </span>            : #define caseMacro(i,j,k,I,J,K) \
<span class="lineNum">    1174 </span>            :                    case I:\
<span class="lineNum">    1175 </span>            :                                   s = sqrt( (mat[I][I] - (mat[J][J]+mat[K][K])) + mat[W][W] );\
<span class="lineNum">    1176 </span>            :                    qu.i() = s*0.5;\
<span class="lineNum">    1177 </span>            :                    s = 0.5 / s;\
<span class="lineNum">    1178 </span>            :                    qu.j() = (mat[I][J] + mat[J][I]) * s;\
<span class="lineNum">    1179 </span>            :                    qu.k() = (mat[K][I] + mat[I][K]) * s;\
<span class="lineNum">    1180 </span>            :                    qu.w() = (mat[K][J] - mat[J][K]) * s;\
<span class="lineNum">    1181 </span>            :                    break
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :                    caseMacro(x,y,z,X,Y,Z);</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                    caseMacro(y,z,x,Y,Z,X);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                    caseMacro(z,x,y,Z,X,Y);</span>
<span class="lineNum">    1185 </span>            :            }
<span class="lineNum">    1186 </span>            :    }
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :    if (mat[W][W] != 1.0) qu = Qt_Scale(qu, 1/sqrt(mat[W][W]));</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :    return (qu);</span>
<span class="lineNum">    1189 </span>            : }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            : /******* Polar Decomposition *******/
<span class="lineNum">    1193 </span>            : /* Polar Decomposition of 3x3 matrix in 4x4,
<span class="lineNum">    1194 </span>            :  * M = QS.  See Nicholas Higham and Robert S. Schreiber,
<span class="lineNum">    1195 </span>            :  * Fast Polar Decomposition of An Arbitrary Matrix,
<span class="lineNum">    1196 </span>            :  * Technical Report 88-942, October 1988,
<span class="lineNum">    1197 </span>            :  * Department of Computer Science, Cornell University.
<a name="1198"><span class="lineNum">    1198 </span>            :  */</a>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 : double polarDecomp( _HMatrix M, _HMatrix Q, _HMatrix S)</span>
<span class="lineNum">    1201 </span>            : {
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            : #define TOL 1.0e-6
<span class="lineNum">    1204 </span>            :         _HMatrix Mk, MadjTk, Ek;
<span class="lineNum">    1205 </span>            :         double det, M_one, M_inf, MadjT_one, MadjT_inf, E_one, gamma, g1, g2;
<span class="lineNum">    1206 </span>            :         int i, j;
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :         mat_tpose(Mk,=,M,3);</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :         M_one = norm_one(Mk);  M_inf = norm_inf(Mk);</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :         do</span>
<span class="lineNum">    1212 </span>            :         {
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 adjoint_transpose(Mk, MadjTk);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                 det = vdot(Mk[0], MadjTk[0]);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                 if (det==0.0)</span>
<span class="lineNum">    1216 </span>            :                 {
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                         do_rank2(Mk, MadjTk, Mk);</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1219 </span>            :                 }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                 MadjT_one = norm_one(MadjTk);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                 MadjT_inf = norm_inf(MadjTk);</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :                 gamma = sqrt(sqrt((MadjT_one*MadjT_inf)/(M_one*M_inf))/fabs(det));</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :                 g1 = gamma*0.5;</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :                 g2 = 0.5/(gamma*det);</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                 matrixCopy(Ek,=,Mk,3);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                 matBinop(Mk,=,g1*Mk,+,g2*MadjTk,3);</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                 mat_copy(Ek,-=,Mk,3);</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :                 E_one = norm_one(Ek);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                 M_one = norm_one(Mk);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                 M_inf = norm_inf(Mk);</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :         } while(E_one&gt;(M_one*TOL));
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :         mat_tpose(Q,=,Mk,3); mat_pad(Q);</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         mat_mult(Mk, M, S);  mat_pad(S);</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;3; i++)</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 for (j=i; j&lt;3; j++)</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                         S[i][j] = S[j][i] = 0.5*(S[i][j]+S[j][i]);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :         return (det);</span>
<span class="lineNum">    1243 </span>            : }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : /******* Spectral Decomposition *******/
<span class="lineNum">    1246 </span>            : /* Compute the spectral decomposition of symmetric positive semi-definite S.
<span class="lineNum">    1247 </span>            : * Returns rotation in U and scale factors in result, so that if K is a diagonal
<span class="lineNum">    1248 </span>            : * matrix of the scale factors, then S = U K (U transpose). Uses Jacobi method.
<a name="1249"><span class="lineNum">    1249 </span>            : * See Gene H. Golub and Charles F. Van Loan. Matrix Computations. Hopkins 1983.</a>
<span class="lineNum">    1250 </span>            : */
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 : HVect spectDecomp(_HMatrix S, _HMatrix U)</span>
<span class="lineNum">    1252 </span>            : {
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :    HVect kv;</span>
<span class="lineNum">    1254 </span>            :    double Diag[3],OffD[3]; /* OffD is off-diag (by omitted index) */
<span class="lineNum">    1255 </span>            :    double g,h,fabsh,fabsOffDi,t,theta,c,s,tau,ta,OffDq,a,b;
<span class="lineNum">    1256 </span>            :    static char nxt[] = {Y,Z,X};
<span class="lineNum">    1257 </span>            :    int sweep, i, j;
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :    mat_copy(U,=,mat_id,4);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :    Diag[X] = S[X][X]; Diag[Y] = S[Y][Y]; Diag[Z] = S[Z][Z];</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :    OffD[X] = S[Y][Z]; OffD[Y] = S[Z][X]; OffD[Z] = S[X][Y];</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :    for (sweep=20; sweep&gt;0; sweep--) {</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :            double sm = fabs(OffD[X])+fabs(OffD[Y])+fabs(OffD[Z]);</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :            if (sm==0.0) break;</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :            for (i=Z; i&gt;=X; i--) {</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                    int p = nxt[i]; int q = nxt[p];</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                    fabsOffDi = fabs(OffD[i]);</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                    g = 100.0*fabsOffDi;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :                    if (fabsOffDi&gt;0.0) {</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                            h = Diag[q] - Diag[p];</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :                            fabsh = fabs(h);</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                            if (fabsh+g==fabsh) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :                                    t = OffD[i]/h;</span>
<span class="lineNum">    1273 </span>            :                            } else {
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                                    theta = 0.5*h/OffD[i];</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                                    t = 1.0/(fabs(theta)+sqrt(theta*theta+1.0));</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :                                    if (theta&lt;0.0) t = -t;</span>
<span class="lineNum">    1277 </span>            :                            }
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :                            c = 1.0/sqrt(t*t+1.0); s = t*c;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :                            tau = s/(c+1.0);</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                            ta = t*OffD[i]; OffD[i] = 0.0;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                            Diag[p] -= ta; Diag[q] += ta;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                            OffDq = OffD[q];</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :                            OffD[q] -= s*(OffD[p] + tau*OffD[q]);</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :                            OffD[p] += s*(OffDq   - tau*OffD[p]);</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :                            for (j=Z; j&gt;=X; j--) {</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :                                    a = U[j][p]; b = U[j][q];</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :                                    U[j][p] -= s*(b + tau*a);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :                                    U[j][q] += s*(a - tau*b);</span>
<span class="lineNum">    1289 </span>            :                            }
<span class="lineNum">    1290 </span>            :                    }
<span class="lineNum">    1291 </span>            :            }
<span class="lineNum">    1292 </span>            :    }
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :    kv.x() = Diag[X]; kv.y() = Diag[Y]; kv.z() = Diag[Z]; kv.w() = 1.0;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :    return (kv);</span>
<span class="lineNum">    1295 </span>            : }
<a name="1296"><span class="lineNum">    1296 </span>            : </a>
<span class="lineNum">    1297 </span>            : /* Return conjugate of quaternion. */
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 : ofQuaternion Qt_Conj(ofQuaternion q)</span>
<span class="lineNum">    1299 </span>            : {
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :         ofQuaternion qq;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     qq.x() = -q.x(); qq.y() = -q.y(); qq.z() = -q.z(); qq.w() = q.w();</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     return (qq);</span>
<span class="lineNum">    1303 </span>            : }
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : /* Return quaternion product qL * qR.  Note: order is important!
<a name="1306"><span class="lineNum">    1306 </span>            :  * To combine rotations, use the product Mul(qSecond, qFirst),</a>
<span class="lineNum">    1307 </span>            :  * which gives the effect of rotating by qFirst then qSecond. */
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 : ofQuaternion Qt_Mul(ofQuaternion qL, ofQuaternion qR)</span>
<span class="lineNum">    1309 </span>            : {
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         ofQuaternion qq;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     qq.w() = qL.w()*qR.w() - qL.x()*qR.x() - qL.y()*qR.y() - qL.z()*qR.z();</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     qq.x() = qL.w()*qR.x() + qL.x()*qR.w() + qL.y()*qR.z() - qL.z()*qR.y();</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     qq.y() = qL.w()*qR.y() + qL.y()*qR.w() + qL.z()*qR.x() - qL.x()*qR.z();</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     qq.z() = qL.w()*qR.z() + qL.z()*qR.w() + qL.x()*qR.y() - qL.y()*qR.x();</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     return (qq);</span>
<span class="lineNum">    1316 </span>            : }
<a name="1317"><span class="lineNum">    1317 </span>            : </a>
<span class="lineNum">    1318 </span>            : /* Construct a (possibly non-unit) quaternion from real components. */
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 : ofQuaternion Qt_(double x, double y, double z, double w)</span>
<span class="lineNum">    1320 </span>            : {
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         ofQuaternion qq;</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     qq.x() = x; qq.y() = y; qq.z() = z; qq.w() = w;</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     return (qq);</span>
<span class="lineNum">    1324 </span>            : }
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            : /******* Spectral Axis Adjustment *******/
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : /* Given a unit quaternion, q, and a scale vector, k, find a unit quaternion, p,
<span class="lineNum">    1329 </span>            :  * which permutes the axes and turns freely in the plane of duplicate scale
<span class="lineNum">    1330 </span>            :  * factors, such that q p has the largest possible w component, i.e. the
<span class="lineNum">    1331 </span>            :  * smallest possible angle. Permutes k's components to go with q p instead of q.
<span class="lineNum">    1332 </span>            :  * See Ken Shoemake and Tom Duff. Matrix Animation and Polar Decomposition.
<a name="1333"><span class="lineNum">    1333 </span>            :  * Proceedings of Graphics Interface 1992. Details on p. 262-263.</a>
<span class="lineNum">    1334 </span>            :  */
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 : ofQuaternion snuggle(ofQuaternion q, HVect *k)</span>
<span class="lineNum">    1336 </span>            : {
<span class="lineNum">    1337 </span>            : #define sgn(n,v)    ((n)?-(v):(v))
<span class="lineNum">    1338 </span>            : #define swap(a,i,j) {a[3]=a[i]; a[i]=a[j]; a[j]=a[3];}
<span class="lineNum">    1339 </span>            : #define cycle(a,p)  if (p) {a[3]=a[0]; a[0]=a[1]; a[1]=a[2]; a[2]=a[3];}\
<span class="lineNum">    1340 </span>            :         else   {a[3]=a[2]; a[2]=a[1]; a[1]=a[0]; a[0]=a[3];}
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         ofQuaternion p = q0001;</span>
<span class="lineNum">    1343 </span>            :         double ka[4];
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         int i, turn = -1;</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :         ka[X] = k-&gt;x(); ka[Y] = k-&gt;y(); ka[Z] = k-&gt;z();</span>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :         if (ka[X]==ka[Y]) {</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 if (ka[X]==ka[Z])</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                         turn = W;</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                 else turn = Z;</span>
<span class="lineNum">    1351 </span>            :         }
<span class="lineNum">    1352 </span>            :         else {
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :                 if (ka[X]==ka[Z])</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :                         turn = Y;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :                 else if (ka[Y]==ka[Z])</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :                         turn = X;</span>
<span class="lineNum">    1357 </span>            :         }
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :         if (turn&gt;=0) {</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :                 ofQuaternion qtoz, qp;</span>
<span class="lineNum">    1360 </span>            :                 unsigned int  win;
<span class="lineNum">    1361 </span>            :                 double mag[3], t;
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :                 switch (turn) {</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :                         default: return (Qt_Conj(q));</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :                         case X: q = Qt_Mul(q, qtoz = qxtoz); swap(ka,X,Z) break;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :                         case Y: q = Qt_Mul(q, qtoz = qytoz); swap(ka,Y,Z) break;</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :                         case Z: qtoz = q0001; break;</span>
<span class="lineNum">    1367 </span>            :                 }
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :                 q = Qt_Conj(q);</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :                 mag[0] = (double)q.z()*q.z()+(double)q.w()*q.w()-0.5;</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                 mag[1] = (double)q.x()*q.z()-(double)q.y()*q.w();</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :                 mag[2] = (double)q.y()*q.z()+(double)q.x()*q.w();</span>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :                 bool neg[3];
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;3; i++)</span>
<span class="lineNum">    1375 </span>            :                 {
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                         neg[i] = (mag[i]&lt;0.0);</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                         if (neg[i]) mag[i] = -mag[i];</span>
<span class="lineNum">    1378 </span>            :                 }
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                 if (mag[0]&gt;mag[1]) {</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                         if (mag[0]&gt;mag[2])</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                                 win = 0;</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :                         else win = 2;</span>
<span class="lineNum">    1384 </span>            :                 }
<span class="lineNum">    1385 </span>            :                 else {
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                         if (mag[1]&gt;mag[2]) win = 1;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                         else win = 2;</span>
<span class="lineNum">    1388 </span>            :                 }
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                 switch (win) {</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :                         case 0: if (neg[0]) p = q1000; else p = q0001; break;</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                         case 1: if (neg[1]) p = qppmm; else p = qpppp; cycle(ka,0) break;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :                         case 2: if (neg[2]) p = qmpmm; else p = qpppm; cycle(ka,1) break;</span>
<span class="lineNum">    1394 </span>            :                 }
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :                 qp = Qt_Mul(q, p);</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :                 t = sqrt(mag[win]+0.5);</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :                 p = Qt_Mul(p, Qt_(0.0,0.0,-qp.z()/t,qp.w()/t));</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :                 p = Qt_Mul(qtoz, Qt_Conj(p));</span>
<span class="lineNum">    1400 </span>            :         }
<span class="lineNum">    1401 </span>            :         else {
<span class="lineNum">    1402 </span>            :                 double qa[4], pa[4];
<span class="lineNum">    1403 </span>            :                 unsigned int lo, hi;
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                 bool par = false;</span>
<span class="lineNum">    1405 </span>            :                 bool neg[4];
<span class="lineNum">    1406 </span>            :                 double all, big, two;
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                 qa[0] = q.x(); qa[1] = q.y(); qa[2] = q.z(); qa[3] = q.w();</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;4; i++) {</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                         pa[i] = 0.0;</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :                         neg[i] = (qa[i]&lt;0.0);</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                         if (neg[i]) qa[i] = -qa[i];</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                         par ^= neg[i];</span>
<span class="lineNum">    1413 </span>            :                 }
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            :                 /* Find two largest components, indices in hi and lo */
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :                 if (qa[0]&gt;qa[1]) lo = 0;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                 else lo = 1;</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                 if (qa[2]&gt;qa[3]) hi = 2;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :                 else hi = 3;</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                 if (qa[lo]&gt;qa[hi]) {</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                         if (qa[lo^1]&gt;qa[hi]) {</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                                 hi = lo; lo ^= 1;</span>
<span class="lineNum">    1425 </span>            :                         }
<span class="lineNum">    1426 </span>            :                         else {
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :                                 hi ^= lo; lo ^= hi; hi ^= lo;</span>
<span class="lineNum">    1428 </span>            :                         }
<span class="lineNum">    1429 </span>            :                 }
<span class="lineNum">    1430 </span>            :                 else {
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :                         if (qa[hi^1]&gt;qa[lo]) lo = hi^1;</span>
<span class="lineNum">    1432 </span>            :                 }
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                 all = (qa[0]+qa[1]+qa[2]+qa[3])*0.5;</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                 two = (qa[hi]+qa[lo])*SQRTHALF;</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                 big = qa[hi];</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :                 if (all&gt;two) {</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :                         if (all&gt;big) {/*all*/</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :                                 {int i; for (i=0; i&lt;4; i++) pa[i] = sgn(neg[i], 0.5);}</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                                 cycle(ka,par);</span>
<span class="lineNum">    1441 </span>            :                         }
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                         else {/*big*/ pa[hi] = sgn(neg[hi],1.0);}</span>
<span class="lineNum">    1443 </span>            :                 } else {
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                         if (two&gt;big) { /*two*/</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                                 pa[hi] = sgn(neg[hi],SQRTHALF);</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                                 pa[lo] = sgn(neg[lo], SQRTHALF);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :                                 if (lo&gt;hi) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                                         hi ^= lo; lo ^= hi; hi ^= lo;</span>
<span class="lineNum">    1449 </span>            :                                 }
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                                 if (hi==W) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                                         hi = &quot;\001\002\000&quot;[lo];</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                                         lo = 3-hi-lo;</span>
<span class="lineNum">    1453 </span>            :                                 }
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                                 swap(ka,hi,lo);</span>
<span class="lineNum">    1455 </span>            :                         }
<span class="lineNum">    1456 </span>            :                         else {/*big*/
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                                 pa[hi] = sgn(neg[hi],1.0);</span>
<span class="lineNum">    1458 </span>            :                         }
<span class="lineNum">    1459 </span>            :                 }
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :                 p.x() = -pa[0]; p.y() = -pa[1]; p.z() = -pa[2]; p.w() = pa[3];</span>
<span class="lineNum">    1461 </span>            :         }
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         k-&gt;x() = ka[X]; k-&gt;y() = ka[Y]; k-&gt;z() = ka[Z];</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :         return (p);</span>
<span class="lineNum">    1464 </span>            : }
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            : /******* Decompose Affine Matrix *******/
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            : /* Decompose 4x4 affine matrix A as TFRUK(U transpose), where t contains the
<span class="lineNum">    1469 </span>            :  * translation components, q contains the rotation R, u contains U, k contains
<span class="lineNum">    1470 </span>            :  * scale factors, and f contains the sign of the determinant.
<span class="lineNum">    1471 </span>            :  * Assumes A transforms column vectors in right-handed coordinates.
<span class="lineNum">    1472 </span>            :  * See Ken Shoemake and Tom Duff. Matrix Animation and Polar Decomposition.
<a name="1473"><span class="lineNum">    1473 </span>            :  * Proceedings of Graphics Interface 1992.</a>
<span class="lineNum">    1474 </span>            :  */
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 : void decompAffine(_HMatrix A, _affineParts * parts)</span>
<span class="lineNum">    1476 </span>            : {
<span class="lineNum">    1477 </span>            :         _HMatrix Q, S, U;
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         ofQuaternion p;</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :         //Translation component.
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         parts-&gt;t = ofVec4f(A[X][W], A[Y][W], A[Z][W], 0);</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         double det = polarDecomp(A, Q, S);</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         if (det&lt;0.0)</span>
<span class="lineNum">    1484 </span>            :         {
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :                 matrixCopy(Q, =, -Q, 3);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :                 parts-&gt;f = -1;</span>
<span class="lineNum">    1487 </span>            :         }
<span class="lineNum">    1488 </span>            :         else
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :                 parts-&gt;f = 1;</span>
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :         parts-&gt;q = quatFromMatrix(Q);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :         parts-&gt;k = spectDecomp(S, U);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         parts-&gt;u = quatFromMatrix(U);</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         p = snuggle(parts-&gt;u, &amp;parts-&gt;k);</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         parts-&gt;u = Qt_Mul(parts-&gt;u, p);</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 : void ofMatrix4x4::decompose( ofVec3f&amp; t,</span>
<span class="lineNum">    1499 </span>            :                    ofQuaternion&amp; r,
<span class="lineNum">    1500 </span>            :                    ofVec3f&amp; s,
<span class="lineNum">    1501 </span>            :                    ofQuaternion&amp; so ) const{
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :         _affineParts parts;</span>
<span class="lineNum">    1504 </span>            :     _HMatrix hmatrix;
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            :     // Transpose copy of LTW
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     for ( int i =0; i&lt;4; i++)</span>
<span class="lineNum">    1508 </span>            :     {
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :         for ( int j=0; j&lt;4; j++)</span>
<span class="lineNum">    1510 </span>            :         {
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :             hmatrix[i][j] = (*this)(j,i);</span>
<span class="lineNum">    1512 </span>            :         }
<span class="lineNum">    1513 </span>            :     }
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     decompAffine(hmatrix, &amp;parts);</span>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     double mul = 1.0;</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     if (parts.t[W] != 0.0)</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :         mul = 1.0 / parts.t[W];</span>
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     t.x = parts.t[X] * mul;</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     t.y = parts.t[Y] * mul;</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :     t.z = parts.t[Z] * mul;</span>
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     r.set(parts.q.x(), parts.q.y(), parts.q.z(), parts.q.w());</span>
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     mul = 1.0;</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :     if (parts.k.w() != 0.0)</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         mul = 1.0 / parts.k.w();</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            :     // mul be sign of determinant to support negative scales.
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     mul *= parts.f;</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :     s.x= parts.k.x() * mul;</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     s.y = parts.k.y() * mul;</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     s.z = parts.k.z() * mul;</span>
<a name="1536"><span class="lineNum">    1536 </span>            : </a>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     so.set(parts.u.x(), parts.u.y(), parts.u.z(), parts.u.w());</span>
<span class="lineNum">    1538 </span><span class="lineCov">        579 : }</span>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            : #undef SET_ROW
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.9</a></td></tr>
  </table>
  <br>

</body>
</html>
